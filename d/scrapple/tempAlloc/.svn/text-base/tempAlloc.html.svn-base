<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>tempalloc</title>
	</head><body>
	<h1>tempalloc</h1>
	<!-- Generated by Ddoc from tempAlloc.d -->
A struct to allocate memory in a strictly first-in last-out order for
 things like scratch space.  Technically, memory can safely escape the
 scope in which it was allocated.  However, this is a very bad idea
 unless being done within the private API of a class, struct or nested
 function, where it can be guaranteed that LIFO will not be violated.
<br><br>
Under the hood, this works by allocating large blocks (currently 4 MB)
 from the GC, and sub-allocating these as a stack.  Very large allocations
 (currently &gt; 4MB) are simply performed on the heap.  There are two ways to
 free memory:  Calling TempAlloc.free() frees the last allocated block.
 Calling TempAlloc.frameFree() frees all memory allocated since the last
 call to TempAlloc.frameInit().
<br><br>

 All allocations are aligned on 16-byte boundaries using padding, since on x86,
 16-byte alignment is necessary to make SSE2 work.  Note, however, that this
 is implemented based on the assumption that the GC allocates using 16-byte
 alignment (which appears to be <b>true</b> in druntime.)

<br><br>
<b>Author:</b><br>
David Simcha
<br><br>
<b>License:</b><br>
Use and redistribution in both binary and source form, both
          modified and unmodified, for both commercian and non-
          commercial purposes is hereby permitted subject to:
<br><br>

          1. The author(s) hereby disclaim all warranties, both express
             and implied.
          2. A statement acknowledging the contributions of the authors
             of this module would be appreciated but is not required.

<br><br>
<font color=red>BUGS:</font><br>
No data stored in memory allocated by TempAlloc is scanned by the
     GC.  This reflects its intended use as a scratch space to store
     things like simple primitives.  Due to <b>false</b> pointer issues, etc.
     making this memory be scanned by the GC would just plain be a bad
     idea.  DO NOT store references to reference types in TempAlloc-
     allocated memory unless you also store a reference in memory that is
     scanned by the GC.
 
<br><br>

<dl><dt><big>struct <u>TempAlloc</u>;
</big></dt>
<dd><br><br>
<dl><dt><big>static nothrow State <u>getState</u>();
</big></dt>
<dd>Allows caller to cache the state class on the stack and pass it in as a
 parameter.  This is ugly, but results in a speed boost that can be
 significant in some cases because it avoids a thread-local storage
 lookup.  Also used internally.
<br><br>

</dd>
<dt><big>static nothrow State <u>frameInit</u>();
</big></dt>
<dd>Initializes a frame, i.e. marks the current allocation position.
 Memory past the position at which this was last called will be
 freed when frameFree() is called.  Returns a reference to the
 State class in case the caller wants to cache it for speed.
<br><br>

</dd>
<dt><big>static nothrow State <u>frameInit</u>(State <i>stateCopy</i>);
</big></dt>
<dd>Same as <u>frameInit</u>() but uses <i>stateCopy</i> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.
<br><br>

</dd>
<dt><big>static nothrow void <u>frameFree</u>();
</big></dt>
<dd>Frees all memory allocated by TempAlloc since the last call to
 frameInit().
<br><br>

</dd>
<dt><big>static nothrow void <u>frameFree</u>(State <i>stateCopy</i>);
</big></dt>
<dd>Same as <u>frameFree</u>() but uses <i>stateCopy</i> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.
<br><br>

</dd>
<dt><big>void* <u>opCall</u>(T...)(T <i>args</i>);
</big></dt>
<dd>Purely a convenience overload, forwards arguments to TempAlloc.malloc().
<br><br>

</dd>
<dt><big>static nothrow void* <u>malloc</u>(size_t <i>nbytes</i>);
</big></dt>
<dd>Allocates <i>nbytes</i> bytes on the TempAlloc stack.  NOT safe for real-time
 programming, since if there's not enough space on the current block,
 a new one will automatically be created.  Also, very large objects
 (currently over 4MB) will simply be heap-allocated.
<br><br>
<font color=red>BUGS:</font><br>
Memory allocated by TempAlloc is not scanned by the GC.
 This is necessary for performance and to avoid <b>false</b> pointer issues.
 Do not store the only reference to a GC-allocated object in
 TempAlloc-allocated memory.
<br><br>

</dd>
<dt><big>static nothrow void* <u>malloc</u>(size_t <i>nbytes</i>, State <i>stateCopy</i>);
</big></dt>
<dd>Same as <u>malloc</u>() but uses <i>stateCopy</i> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.
<br><br>

</dd>
<dt><big>static nothrow void <u>free</u>();
</big></dt>
<dd>Frees the last piece of memory allocated by TempAlloc.  Since
 all memory must be allocated and freed in strict LIFO order,
 there's no need to pass a pointer in.  All bookkeeping for figuring
 out what to <u>free</u> is done internally.
<br><br>

</dd>
<dt><big>static nothrow void <u>free</u>(State <i>stateCopy</i>);
</big></dt>
<dd>Same as <u>free</u>() but uses <i>stateCopy</i> cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.
<br><br>

</dd>
</dl>
</dd>
<dt><big>T[] <u>newStack</u>(T)(size_t <i>size</i>);
</big></dt>
<dd>Allocates an array of type T and size size using TempAlloc.
 Note that appending to this array using the ~= operator,
 or enlarging it using the .length property, will result in
 undefined behavior.  This is because, if the array is located
 at the beginning of a TempAlloc block, the GC will think the
 capacity is as large as a TempAlloc block, and will overwrite
 adjacent TempAlloc-allocated data, instead of reallocating it.
<br><br>
<font color=red>BUGS:</font><br>
Do not store the only reference to a GC-allocated reference object
 in an array allocated by <u>newStack</u> because this memory is not
 scanned by the GC.
<br><br>

</dd>
<dt><big>T[] <u>newStack</u>(T)(size_t <i>size</i>, TempAlloc.State <i>state</i>);
</big></dt>
<dd>Same as <u>newStack</u>(size_t) but uses stateCopy cached on stack by caller
 to avoid a thread-local storage lookup.  Strictly a speed hack.
<br><br>

</dd>
<dt><big>invariant char[] <u>newFrame</u>;
</big></dt>
<dd>A string to mixin at the beginning of a scope, purely for
 convenience.  Initializes a TempAlloc frame using frameInit(),
 and inserts a scope statement to delete this frame at the end
 of the current scope.
<br><br>
Slower than calling free() manually when only a few pieces
 of memory will be allocated in the current scope, due to the
 extra bookkeeping involved.  Can be faster, however, when
 large amounts of allocations, such as arrays of arrays,
 are allocated, due to caching of data stored in thread-local
 storage.
<br><br>

</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
	</body></html>
