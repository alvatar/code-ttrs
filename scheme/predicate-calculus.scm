;;
;; Predicate calculus with equality
;;
;; Read more about Predicate calculus with equality here:
;; http://us.metamath.org/index.html
;; http://www.mathsci.appstate.edu/~jlh/primer/hirst.pdf
;; http://www.enm.bris.ac.uk/research/aigroup/enjl/logic/sld034.htm
;; http://www.cs.mu.oz.au/255/lec/subject-prop_resolution.pdf
;;
;; With code snippets from:
;; comp.lang.scheme
;; http://mitpress.mit.edu/sicp/full-text/book/book.html
;; http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html
;; http://www-swiss.ai.mit.edu/~jaffer/SCM.html
;; http://www.cis.temple.edu/~ingargio/cis587/readings/clausal-alg.cl
;; bit-scheme
;;

(package* predicate-calculus/v1.0.0
  (provide:
    (define (clausal-form formula))
    (define (full-resolution clauses-set))
    (define (add-equality-axioms clauses-set))
  )
  (author: "Naruto Canada <narutocanada@gmail.com")
  (maintainer: "Naruto Canada <narutocanada@gmail.com")
  (homepage: "http://sourceforge.net/projects/math-linux/")
  (description: "Predicate calculus with equality")
  (keywords: logic))
;; 
(define caar (lambda (p) (car (car p))))
(define cadr (lambda (p) (car (cdr p)))) 
(define cdar (lambda (p) (cdr (car p)))) 
(define cddr (lambda (p) (cdr (cdr p)))) 
(define map1 (lambda (f l) (if (null? l) l
 (let* ((x (f (car l))) (y (map1 f (cdr l))) ) (cons x y))))) 
(define map (lambda (proc . ll) (if (null? (car ll)) '() (let* ((tetes
 (map1 car ll)) (queues (map1 cdr ll)) (x (apply proc tetes)) ) (cons x
 (apply map (cons proc queues)))))))
(define for-each (lambda (proc . ll) (if (null? (car ll)) 'void (let ((tetes
 (map car ll))) (let ((queues (map cdr ll))) (begin (apply proc tetes) (apply for-each
 (cons proc queues))) )))))
(define foldr1 (lambda (binop l) (cond ((null? (cdr l)) (car l))
  (else (binop (car l) (foldr1 binop (cdr l)))))))
(define map-print (lambda (m) (map print m) 'void))
(define append2 (lambda (l1 l2) (if (null? l1) l2 (let ((tete (cons (car l1)
  l2))) (let loop ((cur tete) (l1 (cdr l1))) (if (null? l1) tete (begin  
  (set-cdr! cur (cons (car l1) l2)) (loop (cdr cur) (cdr l1)) )))))))
(define append (lambda ll (foldr1 append2 (cons '() ll))))
(define reverse (lambda (l) (let loop ((l l) (rl '())) (if (null? l)
  rl (loop (cdr l) (cons (car l) rl))))))
(define generic-assoc (lambda (releq obj alist) (cond ((null? alist) #f)
  ((releq (car (car alist)) obj) (car alist))
  (else (generic-assoc releq obj (cdr alist))))))
(define assq (lambda (obj alist) (generic-assoc eq? obj alist)))
(define generic-member (lambda (releq obj list) (if (null? list) #f
  (if (releq (car list) obj) list (generic-member releq obj (cdr list))))))
(define memq (lambda (obj list) (generic-member eq? obj list)))

;; 
(define (for-loop x x-max do-stuff) 
  (if (<= x x-max) 
      (begin (do-stuff x) (for-loop (+ x 1) x-max do-stuff)) 
      'void
  )
) 
(define (make-list n x) 
  (define ret '()) 
  (for-loop 1 n (lambda (i) 
    (set! ret (cons x ret))
  )) 
  ret
) 
(define (xor x y) (or (and x (not y)) (and (not x) y))) 
(define interval (lambda (a b) 
  (cond ((> a b) '())
        (else (cons a (interval (+ a 1) b)))
  )
)) 
(define (cross-product lst)
  (define (append-map proc first . rest) (apply append (apply map proc first rest)))
  (if (null? lst) 
      (list '())
      (append-map (lambda (x) (map (lambda (prev-result) (cons x prev-result))
                 (cross-product (cdr lst))))  (car lst)) )) 
(define caaar (lambda (p) (caar (car p)))) 
(define caadr (lambda (p) (caar (cdr p)))) 
(define cadar (lambda (p) (cadr (car p)))) 
(define caddr (lambda (p) (cadr (cdr p)))) 
(define cdaar (lambda (p) (cdar (car p)))) 
(define cdadr (lambda (p) (cdar (cdr p)))) 
(define cddar (lambda (p) (cddr (car p)))) 
(define cdddr (lambda (p) (cddr (cdr p)))) 
(define caaaar (lambda (p) (caaar (car p)))) 
(define caaadr (lambda (p) (caaar (cdr p)))) 
(define caadar (lambda (p) (caadr (car p)))) 
(define caaddr (lambda (p) (caadr (cdr p)))) 
(define cadaar (lambda (p) (cadar (car p)))) 
(define cadadr (lambda (p) (cadar (cdr p)))) 
(define caddar (lambda (p) (caddr (car p)))) 
(define cadddr (lambda (p) (caddr (cdr p)))) 
(define cdaaar (lambda (p) (cdaar (car p)))) 
(define cdaadr (lambda (p) (cdaar (cdr p)))) 
(define cdadar (lambda (p) (cdadr (car p)))) 
(define cdaddr (lambda (p) (cdadr (cdr p)))) 
(define cddaar (lambda (p) (cddar (car p)))) 
(define cddadr (lambda (p) (cddar (cdr p)))) 
(define cdddar (lambda (p) (cdddr (car p)))) 
(define cddddr (lambda (p) (cdddr (cdr p)))) 
(define (first x) (car x)) 
(define (second x) (cadr x)) 
(define (third x) (caddr x)) 
(define (fourth x) (cadddr x)) 
(define (fifth x) (car (cddddr x))) 
(define (last lst) (if (null? (cdr lst)) (car lst) (last (cdr lst)))) 
(define (iff x y) (if (eq? x y) #t #f)) 
(define (implies x y) (if (not x) #t (if (not y) #f #t))) 
(define => implies) 
(define <=> iff) 
(define (prop-calc func lst) (map (lambda (x) (apply func x)) lst)) 
(define count-leaves (lambda (x) 
  (cond ((null? x) 0) ((not (pair? x)) 1)
        (else (+ (count-leaves (car x)) (count-leaves (cdr x))))))) 
(define square (lambda (x) (* x x))) 
(define tree-map (lambda (func tree) 
  (cond ((null? tree) tree) 
        ((not (pair? tree)) (func tree)) 
        (else (cons (tree-map func (car tree) )
                    (tree-map func (cdr tree) )))))) 
(define gensym-counter 0) 
(define (gensym . symstr) 
  (set! gensym-counter (+ gensym-counter 1))
  (if (null? symstr) 
      (string->symbol (string-append "g" (number->string gensym-counter)))
      (string->symbol (string-append (car symstr) (number->string gensym-counter))))) 
(define (tree-sub x y tree) 
  (cond ((null? tree) tree) 
        ((not (pair? tree)) (if (eq? tree x) y tree)) 
        (else (let ((xx (tree-sub x y (car tree))))
                   (cons xx (tree-sub x y (cdr tree))  ) )))) 
(define (safe-tree-sub lst tree) 
  (define tmp (map (lambda (term) (list (car term) (gensym))) lst))
  (for-each (lambda (term) 
    (set! tree (tree-sub (car term) (cadr term) tree))) tmp)
  (for-each (lambda (t1 t2) 
    (set! tree (tree-sub (cadr t1) (cadr t2) tree))) tmp lst)
  tree) 
(define list?
  (lambda (l)
    (cond ((null? l)
           #t)
          ((not (pair? l))
           #f)
          (else
           (let loop ((slow l) (fast (cdr l)) (phase 2))
             (cond ((null? fast)
                    #t)
                   ((not (pair? fast))
                    #f)
                   ((eq? slow fast) 
                    #f)
                   ((= phase 1)
                    (loop slow (cdr fast) 2))
                   (else
                    (loop (cdr slow) (cdr fast) 1))))))))
(define (flatten1 lst) 
  (define ret '()) 
  (for-each (lambda (a) 
    (if (list? a) (set! ret (append ret a)) 
                  (set! ret (append ret (list a))) 
    ) 
  ) lst) 
  ret) 
(define (flatten z) 
  (define y '()) 
  (define (traverse x) 
    (cond ((null? x))
          ((not (pair? x)) (set! y (append y (list x)))) 
          (else (begin (traverse (car x))
                       (traverse (cdr x)))))) 
  (traverse z) 
  y) 
(define (filter predicate sequence) 
  (if (null? sequence) sequence
      (if (predicate (car sequence)) 
          (cons (car sequence) (filter predicate (cdr sequence)))
                               (filter predicate (cdr sequence))))) 
(define (list-copy ls) 
  (if (pair? ls) 
      (cons (list-copy (car ls)) (list-copy (cdr ls))) ls))
(define (nth-cdr n lst) (if (> n 0) (nth-cdr (- n 1) (cdr lst)) lst)) 
(define length (lambda (l) 
  (let loop ((l l) (len 0))
       (if (null? l) len (loop (cdr l) (+ len 1)))))) 
(define (take n lst) 
  (if (<= n 0) '() 
      (if (< n (length lst))
          (reverse (nth-cdr (- (length lst) n) (reverse lst))) lst))) 
(define (iota count begin inc) 
  (if (<= count 0) '()
      (cons begin (iota (- count 1) (+ begin inc) inc)))) 
(define (take-right n lst) (nth-cdr (- (length lst) n) lst)) 
(define (delete = x ls) 
  (define ret '()) 
  (for-each (lambda (y)
    (if (not (= x y)) (set! ret (append ret (list y))))
  ) ls) 
  ret) 
(define (contains? = element lst) 
  (if (null? lst) #f
      (if (= element (car lst)) #t (contains? = element (cdr lst))))) 
(define (list->set = lst) 
  (if (null? lst) lst
      (cons (car lst) (list->set = (delete = (car lst) (cdr lst)))))) 
(define (search-list i = element lst) 
  (if (null? lst) -1 
      (if (= element (car lst)) i 
          (search-list (+ i 1) = element (cdr lst))))) 
(define (set-minus = set1 set2) 
  (define result (list->set = set1))
  (map (lambda (x) (set! result (delete = x result))) set2) result) 
(define (set-cmp? = s1 s2) 
  (and (null? (set-minus = s1 s2)) (null? (set-minus = s2 s1)))) 
(define (idx-interval lst) (interval 0 (- (length lst) 1))) 
(define list-ref (lambda (l pos) (car (nth-cdr pos l)))) 
(define (swap i j lst) 
  (define x (list-ref lst i)) 
  (define y (list-ref lst j)) 
  (map (lambda (z k) (if (= k i) y (if (= k j) x z))) lst (idx-interval lst))) 
(define (swap! i j lst) 
  (define x (list-ref lst i)) 
  (define y (list-ref lst j))
  (set-car! (nth-cdr j lst) x) 
  (set-car! (nth-cdr i lst) y) 
  lst) 
(define (list-set! lst i x) (set-car! (nth-cdr i lst) x) lst) 
(define (nth-apply n func x) 
  (define ret x)
  (for-loop 1 n (lambda (i) (set! ret (func ret)))) ret) 
(define (rotate-right lst) 
  (if (null? lst) lst
      (cons (last lst) (take (- (length lst) 1) lst)))) 
(define (rotate-left ls)  (append (cdr ls) (list (car ls)))) 
(define (transpose matrix) 
  (map (lambda (j) 
    (map (lambda (row) 
      (list-ref row j)
    ) matrix)
  ) (interval 0 (- (length (car matrix)) 1)))
) 
(define (atom? x) (not (pair? x))) 
(define (tree-cmp? = t1 t2) 
  (if (and (null? t1) (null? t2)) #t
      (if (and (not (pair? t1)) (not (pair? t2))) (= t1 t2) 
          (if (not (and (pair? t1) (pair? t2))) #f
              (and (tree-cmp? = (car t1) (car t2)) 
                   (tree-cmp? = (cdr t1) (cdr t2)) ))))) 
(define (tree-eq? t1 t2) (tree-cmp? eq? t1 t2)) 
(define (tree-contains? = x tree) 
  (cond ((null? tree) #f)
        ((not (pair? tree)) (= x tree)) 
        (else (let ((yes (tree-contains? = x (car tree))))
                   (if yes yes (tree-contains? = x (cdr tree))) )))) 
(define (gen-indices-set n) 
  (define ret '()) 
  (for-loop 0 (- n 1) (lambda (i) 
    (for-loop (+ i 1) (- n 1) (lambda (j) 
      (set! ret (append ret (list (cons i j)) ))
    ))
  )) 
  ret) 
;; http://www.cs.bgu.ac.il/~elhadad/scheme/merge.html
;; http://www.cs.bgu.ac.il/~elhadad/scheme/insertion.html
(define (insertion-sort < ls)
  (define (reverse-it ls acc) 
    (if (null? ls) acc (reverse-it (cdr ls) (cons (car ls) acc)))
  )
  (define (insert new sorted)
    (let loop ((rest sorted) (passed '()))
      (cond ((null? rest)       (reverse-it passed (list new)))
            ((< new (car rest)) (reverse-it passed (cons new rest)))
            (else (loop (cdr rest) (cons (car rest) passed)))
      )
    )
  )
  (let outer-loop ((remaining ls) (done '()))
    (if (null? remaining) done
        (outer-loop (cdr remaining) (insert (car remaining) done))
    )
  )
)
(define (collect-leaves- pred tree level position)
  (if (null? tree) tree
      (if (not (pair? tree)) (if (pred level position tree) tree '())
          (if (pair? (car tree))
              (cons (collect-leaves- pred (car tree) (+ 1 level)            0  )
                    (collect-leaves- pred (cdr tree)      level (+ 1 position) )
              )
              (if (pred (+ 1 level) position (car tree) (cdr tree))
                  (cons (car tree) (collect-leaves- pred (cdr tree) level (+ 1 position)))
                                   (collect-leaves- pred (cdr tree) level (+ 1 position))
              )
          ))))
(define (collect-leaves pred tree) (flatten (collect-leaves- pred tree 0 0)))

;;
;; http://www.cis.temple.edu/~ingargio/cis587/readings/clausal-alg.cl
(define (unique-quant-variables formula)
  (if (atom? formula) formula  
    (if (or (eq? 'all (car formula)) (eq? 'exist (car formula))) 
      (let ((gs (gensym "?x")))
        (tree-sub (second formula) gs 
          (list (first formula) (second formula) (unique-quant-variables (third formula)) ) 
        )
      )
      (map (lambda (x)
        (if (atom? x) x (unique-quant-variables x)) 
      ) formula) 
    )
  )      
)
(define (eliminate-iff formula)
  (if (atom? formula) formula  
      (if (eq? '<=> (car formula)) 
          (let ((left (eliminate-iff (cadr formula)))
                (right (eliminate-iff (caddr formula)))
               )
               (list 'and (list '=> left right) (list '=> right left))
          )
          (map (lambda (x)
            (if (atom? x) x (eliminate-iff x)) 
          ) formula) 
      )
  )
)
(define (eliminate-implication formula)
  (if (atom? formula) formula  
      (if (eq? '=> (car formula)) 
          (let ((left (eliminate-implication (cadr formula)))
                (right (eliminate-implication (caddr formula)))
               )
               (list 'or (list 'not left) right) 
          )
          (map (lambda (x)
            (if (atom? x) x (eliminate-implication x) ) 
          ) formula) 
      )
  )
)               
;; (xor A B) <=> (not (or (and A B) (and (not A) (not B))))
(define (eliminate-xor formula)
  (if (atom? formula) formula  
      (if (eq? 'xor (car formula))
          (let ((A (eliminate-xor (cadr formula)))
                (B (eliminate-xor (caddr formula)))
               )
               (list 'not (list 'or (list 'and A B) (list 'and (list 'not A) (list 'not B))))
          )
          (map (lambda (x)
            (if (atom? x) x (eliminate-xor x) )
          ) formula)
      )
  )
)
;; (not (not P)) <=> P 
;; (not (and A B)) <=> (or (not A) (not B))
;; (not (or A B)) <=> (and (not A) (not B))
;; (not (all x P)) <=> (exist x (not P))
;; (not (exist x P)) <=> (all x (not P))
(define (move-not-inwards formula)
 (if (atom? formula) formula  
  (if (eq? 'not (car formula))
   (if (and (pair? (second formula)) (eq? 'not (caadr formula)) )
    (move-not-inwards (cadr (cadr formula)))
    (if (and (pair? (second formula)) (eq? 'all (caadr formula)) )
     (list 'exist (cadr (cadr formula)) (move-not-inwards (list 'not (caddr (cadr formula)))))
     (if (and (pair? (second formula)) (eq? 'exist (caadr formula)) )
      (list 'all (cadr (cadr formula)) (move-not-inwards (list 'not (caddr (cadr formula)))))
      (if (and (pair? (second formula)) (eq? 'and (caadr formula)) )
       (list 'or (move-not-inwards (list 'not (cadr  (cadr formula))))
                 (move-not-inwards (list 'not (caddr (cadr formula)))))
       (if (and (pair? (second formula)) (eq? 'or (caadr formula)) )
        (list 'and (move-not-inwards (list 'not (cadr  (cadr formula))))
                   (move-not-inwards (list 'not (caddr (cadr formula)))))
        formula)))))
   (map (lambda (x)
     (if (atom? x) x (move-not-inwards x) )
   ) formula)
  )
 )
)
(define (skolemise- formula bag bagS)
  (define keywords '(not or and))
  (define bagA 0)(define bagE 0)(define bagX 0)(define idx 0)(define args 0)
  (if (atom? formula) formula  
      (if (eq? 'all (car formula))  
          (begin
            (set! bagS (cons 'bug bagS))
            (set! bag (cons (list 'A (second formula)) bag))
            (skolemise- (third formula) bag bagS)
          )
          (if (eq? 'exist (car formula))
              (begin
                (set! bagS (cons (gensym "skolem") bagS))
                (set! bag (cons (list 'E (second formula)) bag))
                (skolemise- (third formula) bag bagS)
              )
              (if (contains? eq? (car formula) keywords)
                (map (lambda (x)
                  (if (atom? x) x (skolemise- x bag bagS))
                ) formula)
                (begin
                  (set! bagA (map (lambda (x) (if (eq? 'A (car x)) (cadr x) 'IMP)) bag))
                  (set! bagE (map (lambda (x) (if (eq? 'E (car x)) (cadr x) 'IMP)) bag))
                  (set! bagX 
                    (map (lambda (sym)
                      (set! idx (search-list 0 eq? sym bagE))
                      (if (< idx 0) sym (begin
                        (set! args (delete eq? 'IMP (take-right (- (length bag) 1 idx) bagA)))
                        (if (> (length args) 0)
                            (cons (list-ref bagS idx) (reverse args))
                                  (list-ref bagS idx)
                        )
                      ))
                    ) (cdr formula))
                  )
                  (cons (car formula) bagX)
                )
              )
          )    
      )        
  )
)            
(define (skolemise f) (skolemise- f '() '()))

;; (or A (and B C)) <=> (and (or A B) (or A C))
;; (or (and A B) C) <=> (and (or A C) (or B C))
(define (distribute-or-over-and formula)
  (if (atom? formula) formula  
      (if (eq? 'or (car formula))
          (let ((l (distribute-or-over-and (second formula)))
                (r (distribute-or-over-and (third formula)))
               )
               (if (and (pair? l) (eq? 'and (car l))) 
                   (list 'and (distribute-or-over-and (list 'or (second l) r))
                              (distribute-or-over-and (list 'or (third l) r)))
                   (if (and (pair? r) (eq? 'and (car r)) )
                       (list 'and (distribute-or-over-and (list 'or l (second r)))
                                  (distribute-or-over-and (list 'or l (third r))))
                       (list 'or l r)
                   )
               )
          )
          (map (lambda (x)
            (if (atom? x) x (distribute-or-over-and x))
          ) formula)
      )
  )
)
(define (clausal-form- formula)
  (let* ((f1 (unique-quant-variables formula))
         (f2 (eliminate-iff f1))
         (f3 (eliminate-implication f2))
         (f4 (eliminate-xor f3))
         (f5 (move-not-inwards f4))
         (f6 (skolemise f5))
         (f7 (distribute-or-over-and f6))
        )
        f7
  )
)
(define (form-clauses e)
  (define (squash-and f)
    (if (and (pair? f) (eq? (car f) 'and)) 
        (append (squash-and (second f)) (squash-and (third f)))
        (list (squash-or f))
    )
  )
  (define (squash-or f)
    (if (and (pair? f) (eq? (car f) 'or)) 
        (append (squash-or (second f)) (squash-or (third f)))
        (list f)
    )    
  )
  (squash-and e)
)
(define (standardise-variables-apart formula)
  (define (get-vars p)
    (filter (lambda (x) 
              (if (and (symbol? x) (eq? #\? (string-ref (symbol->string x) 0))) #t #f)) 
      (flatten (map (lambda (x) (if (pair? x) (get-vars (cdr x)) x)) p) )
    ) 
  )
  (define (do-clause cl)
    (define bag '())(define subs 0)
    (for-each (lambda (p)
      (if (pair? p) (set! bag (append bag (get-vars (cdr p)))))
    ) cl)
    (set! bag (list->set eq? bag))        ;; distinct variables for the whole clause
    (set! subs (map (lambda (x) (list x (gensym "?x"))) bag)) ;; substitution pattern
    (safe-tree-sub subs cl)
  )
  ;(map (lambda (cl) (do-clause cl)) formula) 
  (list->set (lambda (x y) (set-cmp? tree-eq? x y)) 
    (map (lambda (cl) (list->set tree-eq? (do-clause cl))) formula) 
  )
)
(define (clausal-form formula)
  (let* ((f1 (unique-quant-variables formula))
         (f2 (eliminate-iff f1))
         (f3 (eliminate-implication f2))
         (f4 (eliminate-xor f3))
         (f5 (move-not-inwards f4))
         (f6 (skolemise f5))
         (f7 (distribute-or-over-and f6))
         (f8 (form-clauses f7))
         (f9 (standardise-variables-apart f8))
        )
        f9   
  )      
)
(define (varp x) (and (symbol? x) (eq? #\? (string-ref (symbol->string x) 0))))
(define (occurs s tree) (tree-contains? eq? s tree))

;; lisp <=> scheme 
;; mapcar <=> map
(define remove-if-not filter)

;; these two functions call each other
(define (stop-at-first-match equal? x lst)
  (if (null? lst) lst
      (if (equal? x (car lst)) lst (member x (cdr lst)))
  )
)
(define (member x lst) (stop-at-first-match tree-eq? x lst))
(define (set-difference s1 s2) (set-minus tree-eq? s1 s2))
(define (replace-variables a b) (safe-tree-sub b a)) 
(define (composition assignment1 assignment2)
  (append 
    (map (lambda (var-pair) 
           (list (first var-pair) (replace-variables (second var-pair) assignment2))
    ) assignment1)
    (remove-if-not (lambda (x) 
      (if (> (length 
        (member (first x) (set-difference (map car assignment2) (map car assignment1)))) 0)
        #t #f)
    ) assignment2)
  )
)

;; no difference return #f
;; not unifiable return #t
;; else return difference
(define (find-difference form1 form2)
  (cond ((varp form1) (cond ((eq? form1 form2) #f)
                            ((occurs form1 form2) #t)
                            (else (list form1 form2))))
        ((varp form2) (if (occurs form2 form1) #t (list form2 form1)))
        ((or (not (pair? form1)) (not (pair? form2))) (if (eq? form1 form2) #f #t))
        (else (or (find-difference (first form1) (first form2))
                  (find-difference (cdr form1)   (cdr form2)) 
              ))
  )
)
(define (subst old new tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (if (tree-eq? old tree) new tree))
        (else (if (tree-eq? old tree) new 
                  (cons (subst old new (car tree) )
                        (subst old new (cdr tree) )
                  )
              )
        )
  )  
)
(define (unify form1 form2 assignment)
  (let ((difference-set (find-difference form1 form2)))
       ;(print "-----")(print difference-set)
       (if (eq? #f difference-set) (list assignment form1)
           (if (eq? #t difference-set) (list '() '())
               (unify (subst (first difference-set) (second difference-set) form1)
                      (subst (first difference-set) (second difference-set) form2)
                      (composition assignment (list difference-set))
               )
           )
       )
  )
)
(define (put-into-two-bags clause)
  (define pos-bag '())
  (define neg-bag '())
  (for-each (lambda (term)
    (if (and (pair? term) (eq? (car term) 'not)) 
        (set! neg-bag (cons (second term) neg-bag)) 
        (set! pos-bag (cons term pos-bag)) 
    )
  ) clause)
  (list pos-bag neg-bag)
)
(define (complement-literals? term1 term2)
  (if (or (tree-eq? (list 'not term1) term2)
          (tree-eq? (list 'not term2) term1)) 
      #t #f)
)
(define (take-out-complement-literals clause1 clause2)
  (define delete-cl1 '()) 
  (define delete-cl2 '())
  (for-each (lambda (p)
  (for-each (lambda (q)
    (if (complement-literals? p q) (begin
        (set! delete-cl1 (cons p delete-cl1))
        (set! delete-cl2 (cons q delete-cl2))
    )) 
  ) clause2)
  ) clause1)
  (list (set-minus tree-eq? clause1 delete-cl1) (set-minus tree-eq? clause2 delete-cl2))
)
(define (full-binary-resolution clause1 clause2)
  (let* ((cl1 (put-into-two-bags clause1))
         (cl2 (put-into-two-bags clause2))
         (cl1-pos (car cl1))
         (cl1-neg (second cl1))
         (cl2-pos (car cl2))
         (cl2-neg (second cl2))
         (new-cl1 (list-copy clause1))
         (new-cl2 (list-copy clause2))
         (ret '())
        )
        (for-each (lambda (p)
        (for-each (lambda (q)
          (if (or (null? p) (null? q)) (error "cannot have null literal."))
          (let ((u (unify p q '())))
               (if (not (null? (second u))) (begin
                   ;(print (list 'subs (car u)))
                   (for-each (lambda (subs)
                     (set! new-cl1 (subst (car subs) (second subs) new-cl1)) 
                     (set! new-cl2 (subst (car subs) (second subs) new-cl2)) 
                   ) (car u))
                   (set! ret (cons 
                               (list->set tree-eq? 
                                 (foldr1 append 
                                   (take-out-complement-literals new-cl1 new-cl2)))
                             ret))
                   (set! new-cl1 (list-copy clause1))
                   (set! new-cl2 (list-copy clause2))
               ))
          )
        ) cl2-neg)
        ) cl1-pos)
        (for-each (lambda (p)
        (for-each (lambda (q)
          (if (or (null? p) (null? q)) (error "cannot have null literal."))
          (let ((u (unify p q '())))
               (if (not (null? (second u))) (begin
                   ;(print (list 'subs (car u)))
                   (for-each (lambda (subs)
                     (set! new-cl1 (subst (car subs) (second subs) new-cl1)) 
                     (set! new-cl2 (subst (car subs) (second subs) new-cl2)) 
                   ) (car u))
                   (set! ret (cons 
                               (list->set tree-eq?
                                 (foldr1 append 
                                   (take-out-complement-literals new-cl1 new-cl2))) 
                             ret))
                   (set! new-cl1 (list-copy clause1))
                   (set! new-cl2 (list-copy clause2))
               ))
          )
        ) cl1-neg)
        ) cl2-pos)
        (list->set (lambda (x y) (set-cmp? tree-eq? x y)) ret)
  )
)
(define (factoring- clause)
  (let ((found #f)(ret 0))
    (for-each (lambda (x i) 
    (for-each (lambda (y j) 
      (if (and (not found) (not (= i j)))
          (let ((u (unify x y '())))
            (if (not (null? (second u))) (begin
              (set! ret (safe-tree-sub (car u) (delete tree-eq? y clause)))
              (set! found #t)
            ))
          )
      )
    ) clause (idx-interval clause))
    ) clause (idx-interval clause))
    (if found ret clause)
  )
)
(define (factoring clause)
  (let ((r (factoring- clause)))
       (if (tree-eq? r clause) clause (factoring r)) 
  )
)

;; clause with X and not X
(define (contains-complements? clause)
  (let ((found #f))
    (for-each (lambda (x i) 
    (for-each (lambda (y j) 
      (if (and (not found) (not (= i j)))
          (set! found (complement-literals? x y))
      )
    ) clause (idx-interval clause))
    ) clause (idx-interval clause))
    found
  )
)

(define (full-resolution clauses-set)
  (let* ((len (length clauses-set))
         (M (insertion-sort (lambda (x y) (< (* (length (list-ref clauses-set (car x)))
                                                (length (list-ref clauses-set (cdr x))))
                                             (* (length (list-ref clauses-set (car y)))
                                                (length (list-ref clauses-set (cdr y))))))
              (gen-indices-set len)))
         (ij 0)(tmp 0)(found #f)
        )
        (let iter () (if (and (not (null? M)) (not found)) (begin
          (set! ij (car M)) (set! M (cdr M)) ;; dequeue
          (set! tmp (list->set (lambda (x y) (set-cmp? tree-eq? x y))
                      (map factoring (full-binary-resolution ;; return clauses-set 
                        (list-ref clauses-set (car ij))
                        (list-ref clauses-set (cdr ij))))))
          (if (null? tmp) 'do_nothing ;; no resolution possible
              (if (and (pair? tmp) (contains? (lambda (x y) (set-cmp? tree-eq? x y)) '() tmp))
                  (begin (set! found #t) (set! clauses-set (append clauses-set 
                           (list 'found 'clause-i (list-ref clauses-set (car ij)) 
                             'clause-j (list-ref clauses-set (cdr ij)) 'resolution-set tmp))))
                  (for-each (lambda (tmp)
                    (if (and (not (contains? (lambda (x y) (set-cmp? tree-eq? x y)) tmp clauses-set))
                             (not (contains-complements? tmp));;OK to take out "redundant" clauses?
                        )
                      (begin
                        (set! clauses-set (append clauses-set (list tmp))) 
                        (for-loop 0 (- len 1) (lambda (i)
                          (set! M (append M (list (cons i len))))
                        ))
                        (set! len (+ 1 len))
                        (set! M (insertion-sort 
                            (lambda (x y) (< (* (length (list-ref clauses-set (car x)))
                                                (length (list-ref clauses-set (cdr x))))
                                             (* (length (list-ref clauses-set (car y)))   
                                                (length (list-ref clauses-set (cdr y)))))) M))
                      )
                    )
                  ) tmp)
              )
          )
          ;(print '**********)(map-print clauses-set)(print '**********)
          (iter)
        )))  
        clauses-set
  )
)

(define (find-predicate-symbols clause)
  (list->set eq? (collect-leaves (lambda (l p h . t) (and (= l 2) (= p 0))) clause))
)
(define (find-function-symbols clause)
  (list->set eq? (collect-leaves (lambda (l p h . t) (and (> l 2) (= p 0))) clause))
)

(define (add-equality-axioms clauses-set)
  (define func-syms '())
  (define pred-syms '())
  (for-each (lambda (cl)
    (for-each (lambda (sym)
      (collect-leaves (lambda (l p h . t) 
        (if (and (eq? h sym) (not (eq? h '=))) 
            (set! pred-syms (cons (list h (length (car t))) pred-syms)))) cl)
    ) (find-predicate-symbols (foldr1 append (put-into-two-bags cl))))
    (for-each (lambda (sym)
      (collect-leaves (lambda (l p h . t) 
        (if (and (eq? h sym) (not (eq? h '=))) 
            (set! func-syms (cons (list h (length (car t))) func-syms)))) cl)
    ) (find-function-symbols  (foldr1 append (put-into-two-bags cl))))
  ) clauses-set)  
  (set! pred-syms (list->set tree-eq? pred-syms))
  (set! func-syms (list->set tree-eq? func-syms))
  ;(print '====pred====)(print pred-syms)(print '============)
  ;(print '====func====)(print func-syms)(print '============)
  (set! clauses-set (append clauses-set (clausal-form 
    '(all x (= x x))  
  )))
  (set! clauses-set (append clauses-set (clausal-form 
    '(all x (all y (=> (= x y) (= y x)))) 
  )))
  (set! clauses-set (append clauses-set (clausal-form 
    '(all x (all y (all z (=> (and (= x y) (= y z)) (= x z))))) 
  )))
  (for-each (lambda (pred-sym)
    (if (< (second pred-sym) 1) (error "hello1?"))
    (let ((len (second pred-sym))            
          (l (list (first pred-sym) 'x1))
          (r (list (first pred-sym) 'y1))
          (e (list '= 'x1 'y1))
          (a 0)
         )
         (for-each (lambda (i)
           (set! l (append l (list (string->symbol (string-append "x" (number->string i))))))
           (set! r (append r (list (string->symbol (string-append "y" (number->string i))))))
         ) (interval 2 len)) 
         (for-each (lambda (i)
           (set! e (list 'and (list '= (string->symbol (string-append "x" (number->string i)))
                                       (string->symbol (string-append "y" (number->string i)))) e))
         ) (interval 2 len)) 
         (set! a (list 'all 'x1 (list 'all 'y1 (list '=> e (list '<=> l r)))))
         (for-each (lambda (i)
           (set! a (list 'all (string->symbol (string-append "x" (number->string i))) a))
           (set! a (list 'all (string->symbol (string-append "y" (number->string i))) a))
         ) (interval 2 len)) 
         (set! clauses-set (append clauses-set (clausal-form a)))
         ;(print '====pred====)(print a)(print '============)
    )     
  ) pred-syms)
  (for-each (lambda (func-sym)
    (if (< (second func-sym) 1) (error "hello2?"))
    (let ((len (second func-sym))
          (l (list (first func-sym) 'x1))
          (r (list (first func-sym) 'y1))
          (e (list '= 'x1 'y1))
          (a 0)
         )
         (for-each (lambda (i)
           (set! l (append l (list (string->symbol (string-append "x" (number->string i))))))
           (set! r (append r (list (string->symbol (string-append "y" (number->string i))))))
         ) (interval 2 len)) 
         (for-each (lambda (i)
           (set! e (list 'and (list '= (string->symbol (string-append "x" (number->string i)))
                                       (string->symbol (string-append "y" (number->string i)))) e))
         ) (interval 2 len)) 
         (set! a (list 'all 'x1 (list 'all 'y1 (list '=> e (list '= l r)))))
         (for-each (lambda (i)
           (set! a (list 'all (string->symbol (string-append "x" (number->string i))) a))
           (set! a (list 'all (string->symbol (string-append "y" (number->string i))) a))
         ) (interval 2 len)) 
         (set! clauses-set (append clauses-set (clausal-form a)))
         ;(print '====func====)(print a)(print '============)
    )     
  ) func-syms)
  clauses-set
)
(test*
 (expect* (tree-eq? 
  (clausal-form '(all x (exist y (<=> (P x c) (Q c y)))) )
  `(((not (P ?x4 c)) (Q c (skolem3 ?x4))) ((not (Q c (skolem3 ?x6))) (P ?x6 c)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (P x y) (Q x y)))) )
  `(((not (P ?x10 ?x11)) (Q ?x10 ?x11)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (not (Q x y)) (not (P x y))))) )
  `(((Q ?x16 ?x17) (not (P ?x16 ?x17))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (P x y) (=> (Q x y) (R x y))))) )
  `(((not (P ?x22 ?x23)) (not (Q ?x22 ?x23)) (R ?x22 ?x23)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (and (P x y) (Q x y)) (R x y)))) )
  `(((not (P ?x28 ?x29)) (not (Q ?x28 ?x29)) (R ?x28 ?x29)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (P x y) (or (Q x y) (R x y))))) )
  `(((not (P ?x34 ?x35)) (Q ?x34 ?x35) (R ?x34 ?x35)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (P x y) (and (Q x y) (R x y))))) )
  `(((not (P ?x40 ?x41)) (Q ?x40 ?x41)) ((not (P ?x44 ?x45)) (R ?x44 ?x45)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (all y (=> (or (P x y) (Q x y)) (R x y)))) )
  `(((not (P ?x50 ?x51)) (R ?x50 ?x51)) ((not (Q ?x54 ?x55)) (R ?x54 ?x55)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (exist y (=> (P x y) (Q x y)))) )
  `(((not (P ?x61 (skolem60 ?x61))) (Q ?x61 (skolem60 ?x61))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(not (all x (exist y (=> (P x y) (Q x y))))) )
  `(((P skolem65 ?x66)) ((not (Q skolem65 ?x68))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (not (all x (P x))) (exist x (P x))) )
  `(((P ?x73) (P skolem72)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(<=> (all x (=> (A x) (B x))) (exist x (Q x))) )
  `(((A skolem77) (Q skolem78)) ((not (B skolem77)) (Q skolem78)) ((not (Q ?x79)) (not (A ?x80)) (B ?x80)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (=> (P x) (and (exist y (Q x y)) (exist y (R x y))))) )
  `(((not (P ?x88)) (Q ?x88 (skolem86 ?x88))) ((not (P ?x90)) (R ?x90 (skolem87 ?x90))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (A x) (=> (all x (A x)) (A x))) )
  `(((not (A x)) (not (A skolem93)) (A x)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (all x (A x)) (=> (exist x (A x)) (all x (A x)))) )
  `(((not (A skolem97)) (not (A ?x98)) (A ?x99)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (=> (all x (A x)) (exist y (C y))) (=> (exist x (B x)) (=> (all x (A x)) (exist y (C y))))) )
  `(((A ?x109) (not (B ?x110)) (not (A skolem107)) (C skolem108)) ((not (C ?x113)) (not (B ?x114)) (not (A skolem107)) (C skolem108)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (all x (exist y (B x y z))) (exist y (B x y z))) )
  `(((not (B skolem120 ?x122 z)) (B x skolem121 z)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (all x (exist y (B x y z))) (exist y (B t y z))) )
  `(((not (B skolem127 ?x129 z)) (B t skolem128 z)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(=> (all x (=> (all y (B y)) (exist y (C x y)))) (=> (all y (B y)) (all x (exist y (C x y)))) ) )
  `(((B ?x140) (not (B skolem138)) (C ?x141 (skolem139 ?x141))) ((not (C skolem137 ?x144)) (not (B skolem138)) (C ?x145 (skolem139 ?x145))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(xor A (xor A (xor A A))) )
  `(((not A) A) ((not A)) (A))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (=> (S x) (exist y (and (T y) (E x y))))) )
  `(((not (S ?x151)) (T (skolem150 ?x151))) ((not (S ?x153)) (E ?x153 (skolem150 ?x153))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all x (=> (W x) (S x))) )
  `(((not (W ?x156)) (S ?x156)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(and (W colin) (D colin)) )
  `(((W colin)) ((D colin)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(all z (=> (and (T z) (exist y (and (D y) (E y z)))) (M z))) )
  `(((not (T ?x160)) (not (D ?x161)) (not (E ?x161 ?x160)) (M ?x160)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(not (exist z (and (T z) (M z)))) )
  `(((not (T ?x165)) (not (M ?x165))))
 ))
 (expect* (tree-eq? 
  (clausal-form '(not (=> A (and B (or C (=> D (not (and C (or A (=> D (xor C (<=> C B))))))))))))
  `((A) ((not B) (not C)) ((not B) D) ((not B) C) ((not B) A (not D) (not C) C B) ((not B) A (not D) (not C) C) ((not B) A (not D) (not C) B) ((not B) A (not D) (not C)) ((not B) A (not D) C))
 ))
 (expect* (tree-eq? 
  (clausal-form '(<=> S (and (not P) (=> (not Q) R))) )
  `(((not S) (not P)) ((not S) Q R) (P (not Q) S) (P (not R) S))
 ))
 (expect* (tree-eq? 
  (clausal-form '(not (=> (and A B) C)) )
  `((A) (B) ((not C)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(not (=> (and (and H1 H2) H3) C)) )
  `((H1) (H2) (H3) ((not C)))
 ))
 (expect* (tree-eq? 
  (clausal-form '(not (=> (and (and (and H1 H2) H3) H4) C)) )
  `((H1) (H2) (H3) (H4) ((not C)))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (all y (A x y))) (all y (all x (A x y)))))))
  `(((A ?x173 ?x174)) ((not (A skolem172 skolem171))) found clause-i ((A ?x173 ?x174)) clause-j ((not (A skolem172 skolem171))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (and (A x) (B x)) (A x)))))
  `(((A x)) ((B x)) ((not (A x))) found clause-i ((A x)) clause-j ((not (A x))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (and (A x) (B x))) (all x (A x))))))
  `(((A ?x181)) ((B ?x183)) ((not (A skolem180))) found clause-i ((A ?x181)) clause-j ((not (A skolem180))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (A x)) (all x (or (A x) (B x)))))))
  `(((A ?x188)) ((not (A skolem187))) ((not (B skolem187))) found clause-i ((A ?x188)) clause-j ((not (A skolem187))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (=> (A x) (B x))) (=> (all x (A x)) (all x (B x)))))))
  `(((not (A ?x194)) (B ?x194)) ((A ?x196)) ((not (B skolem193))) ((B ?x194)) found clause-i ((not (B skolem193))) clause-j ((B ?x194)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (B x)) (all x (=> (A x) (B x)))))))
  `(((B ?x201)) ((A skolem200)) ((not (B skolem200))) found clause-i ((B ?x201)) clause-j ((not (B skolem200))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (all y (A x y))) (all y (all x (A y x)))))))
  `(((A ?x209 ?x210)) ((not (A skolem207 skolem208))) found clause-i ((A ?x209 ?x210)) clause-j ((not (A skolem207 skolem208))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (or (A x) (B x))) (=> (all x (not (A x))) (all x (B x)))))))
  `(((A ?x218) (B ?x218)) ((not (A ?x220))) ((not (B skolem217))) ((B ?x220)) found clause-i ((not (B skolem217))) clause-j ((B ?x220)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (A x) (exist x (A x))))))
  `(((A x)) ((not (A ?x223))) found clause-i ((A x)) clause-j ((not (A ?x223))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (all y (=> (A y y) (exist x (A x y)))))))
  `(((A skolem227 skolem227)) ((not (A ?x228 skolem227))) found clause-i ((A skolem227 skolem227)) clause-j ((not (A ?x228 skolem227))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (A x)) (exist x (A x))))))
  `(((A ?x232)) ((not (A ?x234))) found clause-i ((A ?x232)) clause-j ((not (A ?x234))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all y (A y)) (exist x (A x))))))
  `(((A ?x238)) ((not (A ?x240))) found clause-i ((A ?x238)) clause-j ((not (A ?x240))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (or (A x) (B x))) (or (all x (A x)) (exist x (B x)))))))
  `(((A ?x246) (B ?x246)) ((not (A skolem245))) ((not (B ?x248))) ((B skolem245)) found clause-i ((not (B ?x248))) clause-j ((B skolem245)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (not (exist x (A x))) (all x (not (A x)))))))
  `(((not (A ?x253))) ((A skolem252)) found clause-i ((not (A ?x253))) clause-j ((A skolem252)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (not (A x))) (not (exist x (A x)))))))
  `(((not (A ?x258))) ((A skolem257)) found clause-i ((not (A ?x258))) clause-j ((A skolem257)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (not (A x))) (not (all x (A x)))))))
  `(((not (A skolem262))) ((A ?x263)) found clause-i ((not (A skolem262))) clause-j ((A ?x263)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (not (all x (A x))) (exist x (not (A x)))))))
  `(((not (A skolem267))) ((A ?x268)) found clause-i ((not (A skolem267))) clause-j ((A ?x268)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (and (A x) (B x))) (exist x (A x))))))
  `(((A skolem272)) ((B skolem272)) ((not (A ?x273))) found clause-i ((A skolem272)) clause-j ((not (A ?x273))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (A x)) (exist x (or (A x) (B x)))))))
  `(((A skolem277)) ((not (A ?x278))) ((not (B ?x280))) found clause-i ((A skolem277)) clause-j ((not (A ?x278))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (all y (A x y))) (all y (exist x (A x y)))))))
  `(((A skolem286 ?x288)) ((not (A ?x290 skolem287))) found clause-i ((A skolem286 ?x288)) clause-j ((not (A ?x290 skolem287))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (=> (A x) (B x))) (=> (all x (A x)) (exist x (B x)))))))
  `(((not (A skolem296)) (B skolem296)) ((A ?x297)) ((not (B ?x299))) ((B skolem296)) found clause-i ((not (B ?x299))) clause-j ((B skolem296)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (B x)) (exist x (=> (A x) (B x)))))))
  `(((B skolem303)) ((A ?x304)) ((not (B ?x306))) found clause-i ((B skolem303)) clause-j ((not (B ?x306))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (not (all x (A x))) (exist x (=> (A x) (B x)))))))
  `(((not (A skolem310))) ((A ?x311)) ((not (B ?x313))) found clause-i ((not (A skolem310))) clause-j ((A ?x311)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (=> (all x (A x)) (exist x (B x))) (exist x (=> (A x) (B x)))))))
  `(((not (A skolem318)) (B skolem319)) ((A ?x320)) ((not (B ?x322))) ((B skolem319)) found clause-i ((not (B ?x322))) clause-j ((B skolem319)) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (all x (A x x)) (all x (exist y (A x y)))))))
  `(((A ?x328 ?x328)) ((not (A skolem327 ?x330))) found clause-i ((A ?x328 ?x328)) clause-j ((not (A skolem327 ?x330))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (all y (exist x (or (not (A y x)) (A y y)))))))
  `(((A skolem335 ?x336)) ((not (A skolem335 skolem335))) found clause-i ((A skolem335 ?x336)) clause-j ((not (A skolem335 skolem335))) resolution-set (()))
 ))
 (expect* (tree-eq? 
  (full-resolution (clausal-form '(not (=> (exist x (or (A x) (B x))) (or (exist x (A x)) (exist x (B x)))))))
  `(((A skolem341) (B skolem341)) ((not (A ?x342))) ((not (B ?x344))) ((B skolem341)) found clause-i ((not (B ?x344))) clause-j ((B skolem341)) resolution-set (()))
 ))
)
